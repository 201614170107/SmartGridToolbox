<!DOCTYPE html>
<html>
	<head>
		<meta charset='utf-8' />
		<meta http-equiv="X-UA-Compatible" content="chrome=1" />
		<meta name="description" content="NICTA SmartGridToolbox : Microgrid tutorial" />
		<link rel="stylesheet" type="text/css" media="screen" href="stylesheets/stylesheet.css">
		<title>NICTA SmartGridToolbox Architecture</title>
	</head>
	<body>
	<!-- MAIN CONTENT -->
		<div id="main_content_wrap" class="outer">
			<section id="main_content" class="inner">
				<p>
					<img src="https://github.inside.nicta.com.au/dgordon/SmartGridToolbox/blob/master/images/logo.png?raw=true" alt="SmartGridToolbox Logo">
				</p>
				<h3><a name="sgt-architecture" class="anchor" href="#sgt-architecture"></a>Introduction to the SmartGridToolbox Architecture</h3>
				<p>
					SmartGridToolbox is a library that can be used to rapidly develop simulations of of smart grid and microgrid systems. It is written in C++11, and users will need access to a compiler that can handle this C++ specification.
				</p>
				<h4><a name="sgt-libraries" class="anchor" href="#sgt-libraries"></a>SmartGridToolbox Libraries</h4>
				<p>
					SmartGridToolbox consists of two libraries: <strong>SgtCore</strong> , which contains core utilities and powerflow modelling tools and solvers, and <strong>SgtSim</strong>, which contains the simulation architecture and simulation components. SgtCore may be used in a standalone manner, for non-simulation based tasks. SgtSim is built on top of SgtCore. In the following, we will assume that SmartGridToolbox has already been compiled and installed in the default location, <code>/usr/local</code>.
				</p>
				<h5><a name="sgt-libraries-including" class="anchor" href="#sgt-libraries-including"></a>Including and linking the SmartGridToolbox libraries</h5>
				<p>
					SmartGridToolbox programs will need to link to the SmartGridToolbox libraries, and will need to include the relevant SmartGridToolbox header files.
				</p>
				<p>
					Header files may be included individually, as follows, e.g.:
<pre><code>#include &ltSgtCore/Network.h&gt
#include &ltSgtSim/Simulation.h&gt
</code></pre>
					or they may be all included automatically using 
<pre><code>#include &ltSgtCore.h&gt
#include &ltSgtSim.h&gt
</code></pre>
				</p>
				<p>
					SmartGridToolbox uses the GNU autotools build system, and builds libraries using libtool. By default, static libraries only are built; for dynamic libraries, SmartGridToolbox should be <code>configure</code>d with the <code>--enable-shared</code> option.
				</p>
				<p>
					The easiest cross-platform way to link to your application is to also use libtool with the GNU autotools. <code>SmartGridToolbox/tutorials/Simulation/Makefile.am</code> gives an example of how to do this. Libtool handles all library dependencies, and correctly handles shared libraries in a manner that is appropriate for the architecture.
				</p>
				<p>
					Otherwise, you must choose	the correct static and dynamic libraries. To statically link a program, the following link flags will work: <code>-lSgtCore -lSgtSim -larmadillo -lboost_date_time -lyaml-cpp</code>. If your program is using <code>SgtCore</code> only, then obviously the <code>-lSgtSim</code> flag should be omitted.
				</p>
				<h4><a name="sgt-utsl" class="anchor" href="#sgt-utsl"></a>Use the Source, Luke</h4>
				<p>
					At present, the SmartGridToolbox documentation is somewhat sketchy. Users are encouraged to explore the source code, either directly, or through the <a href="doxygen_docs/index.html">doxygen documentation</a> (organised by functional modules <a href="doxygen_docs/modules.html">here</a>). 
				</p>
					In terms of the SmartGridToolbox directory structure, core and non-simulation functionalities are located in the <code>SgtCore</code> subdirectory and the simulation engine and components are located in <code>SgtSim</code>. The <code>src</code> directory contains the source code for simple applications (providing a good reference for how to use the SmartGridToolbox library. <code>test</code> provides unit tests, which can also be a good reference. <code>tutorials</code> contains annotated <a href="#tutorials">tutorials</a>, and <code>examples</code> contains more developed examples, which give a sample of how SmartGridToolbox can be used.
				</p>
				<h4><a name="sgt-foundation" class="anchor" href="#sgt-foundation"></a>SmartGridToolbox Foundation Classes and Functions</h4>
				<h5><a name="sgt-component" class="anchor" href="#sgt-component"></a>The Component class</h5>
				<p>
					Most objects in SmartGridToolbox models and simulations derive from the <code><a href="doxygen_docs/class_sgt_1_1_component.html">Component</a></code> class. The most important function of this class is to provide a unique key (a <code>std::string</code>) for each object. <code>Component</code>s are also able to provide a component type string, to print themselves, and to act as an access point to an objects <code>Property</code>s. 
				</p>
				<h5><a name="sgt-event" class="anchor" href="#sgt-event"></a>The Event and Action classes</h5>
				<p>
					The event processing interface in SmartGridToolbox revolves around two classes: the <code><a href="doxygen_docs/class_sgt_1_1_event.html">Event</a></code> class, and the <code><a href="doxygen_docs/class_sgt_1_1_event.html">Action</a></code> class. These two classes are frequently used in simulations, for example to communicate that a change in one component should trigger an update in another.
				</p>
				<p>
					<code>Event</code> objects represent events that may be triggered. Each event holds a list of <code>Action</code> objects, that perform some arbitrary action when the event is triggered, in the form of a C++11 lambda.
				</p>
				<p>
					The following example shows how events and actions work together:
<pre><code>Event event("this is an event");
event.addAction([] () {std::cout << "beep!" << std::endl;});
event.trigger();
</code></pre>
					which will cause "beep!" to be printed.
				</p>
				<h5><a name="sgt-prop" class="anchor" href="#sgt-prop"></a>Properties</h5>
				<p>
					It is often useful (for example, when writing a GUI) to have a more dynamic representation of the properties of an object than is provided by the C++ syntax. We would sometimes like to dynamically add properties to a class, and to dynamically get and set them, without first knowing what the set of properties is for an object.
				</p>
				<p>
					SmartGridToolbox defines a <code><a href="doxygen_docs/class_sgt_1_1_property.html">Property&ltT&gt</a></code> template class, that represents a property of type <code>T</code> (say, <code>int</code>, <code>double</code> or <code>arma::Col&ltComplex&gt</code>), that may be gotten and/or set. A non-template base class, <code><a href="doxygen_docs/class_sgt_1_1_property_base.html">PropertyBase</a></code>, provides a string-based interface for getting and setting properties when we don't know their type.
					
					For a class to implement properties, it should derive from the <code><a href="doxygen_docs/class_sgt_1_1_has_properties_interface.html">HasPropertiesInterface</a></code>, class.
				</p>
				<p>
					The following code snippet shows properties in action:
				</p>
<pre><code>#include &ltSgtCore/Properties.h&gt

class Foo : public Sgt::HasProperties&ltFoo>
{
    public:
        SGT_PROPS_INIT(Foo);                                                               

        int four() const {return 4;}
        SGT_PROP_GET(fourProp, Foo, int, four);
};

class Bar : public Foo, public Sgt::HasProperties&ltBar&gt
{
    public:
        SGT_PROPS_INIT(Bar);                                                               
        SGT_PROPS_INHERIT(Bar, Foo);          

        int x() const {return x_;}
        void setX(int x) {x_ = x;}
        SGT_PROP_GET_SET(xProp, Bar, int, x, setX);

    public:
        int x_{5};
};
        

int main()
{
    Bar bar;
    for (auto& p : bar.properties())
    {
        std::cout << "Property " << p.first << " : " << p.second->string(bar) << std::endl;
    }
    Sgt::PropertyBase& xProp = *bar.properties()["xProp"];
    std::cout << "xProp as string : " << xProp.string(bar) << std::endl;
    std::cout << "xProp as int : " << xProp.get&ltint&gt(bar) << std::endl;
    xProp.set&ltint&gt(bar, 345);
    std::cout << "bar.x() should now be 345 : " << bar.x() << std::endl;
    xProp.setFromString(bar, "678");
    std::cout << "bar.x() should now be 678 : " << bar.x() << std::endl;
};</code></pre>
				<h4><a name="sgt-power-flow" class="anchor" href="#sgt-power-flow"></a>Power Flow Problems</h4>
				</p>
					Power Flow modelling and solution forms a key part of SmartGridToolbox. The overarching class used in modeling power flow problems is the <code><a href="doxygen_docs/class_sgt_1_1_network.html">Network</a></code> class.
					
				</p>
				<p> 
					Network objects act as a container for network Components. There are four classes of network components: <code><a href="doxygen_docs/class_sgt_1_1_bus.html">Bus</a></code>ses, <code><a href="doxygen_docs/class_sgt_1_1_branch_abc.html">Branch</a></code>es, <code><a href="doxygen_docs/class_sgt_1_1_gen_abc.html">Gen</a></code>s and <code><a href="doxygen_docs/class_sgt_1_1_zip_abc.html">Zip</a></code>s.
				</p>
				<p>
					To understand how these components work together, the reader should first understand the classic power flow (or optimal power flow) problem, which is beyond the scope of this documentation. Briefly, though, busses are like conductor terminals: they are points or nodes in the network at which a single voltage exists. Branches are the lines, transformers and other connective components that join together busses. Gens (generators) normally represent generation of power, and act as injections of power from the ground to a bus. Zips are also power injections into a bus, but they normally represent network loads (consumption), and thus the injection is usually negative. They follow the commonly used ZIP (constant Z, I, P component) load model. The power flow problem revolves around finding the voltages and power injections at each bus so that the Kirchoff network laws and are satisfied while also satisfying requirements on the power injections and/or voltages.
				</p>
				<p>
					Network modelling and power flow solving is covered in the <a href="network_tutorial.html">network tutorial</a>. It starts with creating or parsing a <code>Network</code> object. <code>Network::solvePowerFlow</code> may then be called. Different solvers can be used by calling <code>Network::setSolver</code>; the default is to use the <a href="doxygen_docs/class_sgt_1_1_power_flow_nr_solver.html">Newton-Raphson AC power flow solver</a>, but an <a href="doxygen_docs/class_sgt_1_1_power_flow_pt_pp_solver.html">OPF solver</a> based on the PowerTools library is also available, and other solvers such as a DC power flow solver are planned.
				</p>
				<h4><a name="sgt-sim" class="anchor" href="#sgt-sim"></a>The Simulation Class</h4>
				<p>
					The bread and butter of SmartGridToolbox is simulation. The <code><a href="doxygen_docs/class_sgt_1_1_simulation.html">Simulation</a></code> class is a container for simulation components, or <code><a href="doxygen_docs/class_sgt_1_1_sim_component.html">SimComponent</a></code>s, and is responsible for running the simulation and coordinating the time propagation and interaction between all of the components.
					
					A basic introduction to simulations can be found in the <a href="simulation_tutorial.html">simulation tutorial</a>. First, the user adds, or parses in, all of the <code><a href="doxygen_docs/class_sgt_1_1_sim_component.html">SimComponent</a></code>s and other simulation related information. <code>Simulation::init()</code> is then called, to initialize the simulation and all its components to the starting time, and to make sure that everything is valid. The simulation can then be progressed forward in time, typically by repeatedly calling <code>Simulation::doTimestep()</code> in a loop.
				</p>
				<h5><a name="sgt-sim" class="anchor" href="#sgt-sim-detailed"></a>A more detailed look at the simulation architecture</h5>
				<p>
					SmartGridToolbox 
				</p>
				<p>
					Each <code>SimComponent</code> is required or able to implement several simulation related methods. 
					<dl>
						<dt><code>Time validUntil() const</code></dt>
						<dd>return the time when the component is scheduled to do its next update (in the absense of being explicitly called on to update by another component).</dd>
						<dt><code>void initializeState()</code></dt>
						<dd>set the state of the component to its initial state.</dd>
						<dt><code>void updateState(Time t)</code></dt>
						<dd>update the state of the component to time t.</dd>
					</dl>
					Each component will implement one these differently, depending on its behaviour.
				</p>
				<p>
					When <code>Simulation::init()</code> is called, <code>initState</code> gets called for each of the components.
				</p>
			</section>
		</div>
	</body>
</html>
