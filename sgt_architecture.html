<!DOCTYPE html>
<html>
	<head>
		<meta charset='utf-8' />
		<meta http-equiv="X-UA-Compatible" content="chrome=1" />
		<meta name="description" content="NICTA SmartGridToolbox : Microgrid tutorial" />
		<link rel="stylesheet" type="text/css" media="screen" href="stylesheets/stylesheet.css">
		<title>NICTA SmartGridToolbox Architecture</title>
	</head>
	<body>
	<!-- MAIN CONTENT -->
		<div id="main_content_wrap" class="outer">
			<section id="main_content" class="inner">
				<p>
					<img src="https://github.inside.nicta.com.au/dgordon/SmartGridToolbox/blob/master/images/logo.png?raw=true" alt="SmartGridToolbox Logo">
				</p>
				<h3><a name="sgt-architecture" class="anchor" href="#sgt-architecture"></a>Introduction to the SmartGridToolbox Architecture</h3>
				<p>
					SmartGridToolbox is a library that can be used to rapidly develop simulations of of smart grid and microgrid systems. It is written in C++-11, and users will need access to a compiler that can handle this C++ specification.
				</p>
				<h4><a name="sgt-library" class="anchor" href="#sgt-library"></a>Including and linking the SmartGridToolbox library</h4>
				<p>
					SmartGridToolbox programs will need to link to the SmartGridToolbox library, and will need to include the relevant SmartGridToolbox header files.
				</p>
				<p>
					Header files may be included individually, as follows:
<pre><code>#include &ltSmartGridToolbox/Model.h&gt
#include &ltSmartGridToolbox/Simulation.h&gt
// ... 
</code></pre>
					or they may be all included automatically using <pre><code>#include &ltSmartGridToolbox.h&gt</code></pre>
				</p>
				<p>
					When linking, you should include <code>-lSmartGridToolbox</code> in the compiler link flags. (If you use the MicrogridTutorial example as a template, including the autoconf and automake scripts, then this will be done automatically). Your compiler will also need to be able to find the SmartGridToolbox library; you may need to add an extra <code>-L</code> compile flag if you have installed it in a non-standard location.
				</p>
				<h4><a name="sgt-program-structure" class="anchor" href="#sgt-program-structure"></a>Basic structure of a SmartGridToolbox program</h4>
				<p>
					At the top level, a SmartGridToolbox simulation will have two basic objects: a <code>Model</code> object, and a <code>Simulation</code> object. The model manages the elements, or <em>components</em> used in the simulation, and the simulation is responsible for advancing time for all the components of the model.
				</p>
				<p>
					The following simple program can be found in <code>/Users/dgordon/Devel/SmartGridToolbox/docs/tutorials/IntroductionToSgt/src/tickers.cc</code>.
<pre><code>#include &ltSmartGridToolbox.h&gt

int main()
{
   using SmartGridToolbox::Model;
   using SmartGridToolbox::RegularUpdateComponent;
   using seconds = SmartGridToolbox::posix_time::seconds;
   using SmartGridToolbox::Simulation;

   // Create the model:
   Model mod;

   // Now populate the model using factory functionality of Model.
   // The RegularUpdateComponent does nothing other than regularly update itself, every 1 second in this case.
   RegularUpdateComponent & ticker1 = 
      mod.newComponent<RegularUpdateComponent>("ticker_1");
   ticker1.setDt(seconds(1));
   // And here's one that updates every 2 seconds...
   RegularUpdateComponent & ticker2 = 
      mod.newComponent<RegularUpdateComponent>("ticker_2");
   ticker2.setDt(seconds(2));

   mod.validate();

   // Set up the simulation.
   Simulation sim(mod);
   sim.setStartTime(seconds(0));
   sim.setEndTime(seconds(5));
   sim.initialize();

   std::cout << "Initial timestep : simulation is at time = " << sim.currentTime() << "." << std::endl;
   std::cout << "                 : ticker_1 is at time = " << ticker1.time() << "." << std::endl;
   std::cout << "                 : ticker_2 is at time = " << ticker2.time() << "." << std::endl;
   std::cout << std::endl;
   while (sim.doTimestep())
   {
      std::cout << "New timestep     : simulation is at time = " << sim.currentTime() << "." << std::endl;
      std::cout << "                 : ticker_1 is at time = " << ticker1.time() << "." << std::endl;
      std::cout << "                 : ticker_2 is at time = " << ticker2.time() << "." << std::endl;
      std::cout << std::endl;
   }
}</code></pre>
				</p>
				<p>
					It illustrates both how to set up a simple SmartGridToolbox program, and certain simple aspects of the event based simulation architecture. Note that at each timestep, more than one component update may occur. To get finer control over the updates, we can change the final <code>while</code> loop so that looping occurs at every single component update, but changing <code>while (sim.doTimestep())</code> to <code>while (sim.doNextUpdate())</code> <em>Exercise: copy the tutorial directory and try it.</em>
				</p>
				<p>
					The output, upon running the program above, is:
					<pre><code>MESSAGE:	Component ticker_1 added to model.
MESSAGE:	Component ticker_2 added to model.
MESSAGE:	Model after validation:
MESSAGE:		ticker_1 0
MESSAGE:		ticker_2 0
Initial timestep : simulation is at time = 00:00:00.
                 : ticker_1 is at time = 00:00:00.
                 : ticker_2 is at time = 00:00:00.

New timestep     : simulation is at time = 00:00:01.
                 : ticker_1 is at time = 00:00:01.
                 : ticker_2 is at time = 00:00:00.

New timestep     : simulation is at time = 00:00:02.
                 : ticker_1 is at time = 00:00:02.
                 : ticker_2 is at time = 00:00:02.

New timestep     : simulation is at time = 00:00:03.
                 : ticker_1 is at time = 00:00:03.
                 : ticker_2 is at time = 00:00:02.

New timestep     : simulation is at time = 00:00:04.
                 : ticker_1 is at time = 00:00:04.
                 : ticker_2 is at time = 00:00:04.</code></pre>
				</p>
			</section>
		</div>
	</body>
</html>
