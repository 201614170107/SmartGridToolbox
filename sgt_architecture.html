<!DOCTYPE html>
<html>
	<head>
		<meta charset='utf-8' />
		<meta http-equiv="X-UA-Compatible" content="chrome=1" />
		<meta name="description" content="NICTA SmartGridToolbox : Microgrid tutorial" />
		<link rel="stylesheet" type="text/css" media="screen" href="stylesheets/stylesheet.css">
		<title>NICTA SmartGridToolbox Architecture</title>
	</head>
	<body>
	<!-- MAIN CONTENT -->
		<div id="main_content_wrap" class="outer">
			<section id="main_content" class="inner">
				<p>
					<img src="https://github.inside.nicta.com.au/dgordon/SmartGridToolbox/blob/master/images/logo.png?raw=true" alt="SmartGridToolbox Logo">
				</p>
				<h3><a name="sgt-architecture" class="anchor" href="#sgt-architecture"></a>Introduction to the SmartGridToolbox Architecture</h3>
				<p>
					SmartGridToolbox is a library that can be used to rapidly develop simulations of of smart grid and microgrid systems. It is written in C++-11, and users will need access to a compiler that can handle this C++ specification.
				</p>
				<h4><a name="sgt-library" class="anchor" href="#sgt-library"></a>SmartGridToolbox libraries</h4>
				<p>
					SmartGridToolbox consists of two libraries: <strong>SgtCore</strong> , which contains core utilities and powerflow modelling tools, and <strong>SgtSim</strong>, which contains the simulation architecture and simulation components. SgtCore may be used in a standalone manner, for non-simulation based tasks. SgtSim is built on top of SgtCore.
				</p>
				<p>
					If, for example, you are installing in <code>/usr/local</code>, the static libraries <code>libSgtCore.a</code> and <code>libSgtSim.a</code> will be installed in <code>/usr/local/lib</code>. The individual header files will be installed in <code>/usr/local/include/SgtCore</code> and <code>/usr/local/include/SgtSim</code>. Additional headers <code>SgtCore.h</code> and <code>SgtSim.h</code> will be installed in <code>/usr/local/include</code>, which will allow the user to include all of the individual headers using single include statements.
				</p>
				<h4><a name="sgt-library" class="anchor" href="#sgt-library"></a>Including and linking the SmartGridToolbox libraries</h4>
				<p>
					SmartGridToolbox programs will need to link to the SmartGridToolbox libraries, and will need to include the relevant SmartGridToolbox header files.
				</p>
				<p>
					Header files may be included individually, as follows, e.g.:
<pre><code>#include &ltSgtCore/Network.h&gt
#include &ltSgtSim/Simulation.h&gt
// ... 
</code></pre>
					or they may be all included automatically using 
<pre><code>#include &ltSgtCore.h&gt
#include &ltSgtSim.h&gt
</code></pre>
				</p>
				<p>
					When linking, you should include <code>-lSgtCore</code> and/or <code>-lSgtSim</code> in the compiler link flags. (If you use the MicrogridTutorial example as a template, including the autoconf and automake scripts, then this will be done automatically). Your compiler will also need to be able to find the SmartGridToolbox library; you may need to add an extra <code>-L</code> compile flag if you have installed it in a non-standard location.
				</p>
				<p> you will also need to link to the other dependent libraries. Thus, the following will be needed:
				<pre><code>-lSgtCore -lSgtSim -larmadillo -lboost_date_time-mt -lyaml-cpp -lklu -lamd -lcolamd -lbtf</code></pre> although the <code>-lSgtSim</code> may be dropped for non-simulation based applications.
				<h4><a name="sgt-program-structure" class="anchor" href="#sgt-program-structure"></a>Basic structure of a SmartGridToolbox program</h4>
				<p>
					At the top level, a SmartGridToolbox simulation will have two basic objects: a <code>Model</code> object, and a <code>Simulation</code> object. The model manages the elements, or <em>components</em> used in the simulation, and the simulation is responsible for advancing time for all the components of the model.
				</p>
				<p>
					The following simple program can be found in <code>SmartGridToolbox/tutorials/IntroductionToSgt/src/tickers.cc</code>.
<pre><code>#include &ltSmartGridToolbox.h&gt

int main()
{
   using SmartGridToolbox::Model;
   using SmartGridToolbox::RegularUpdateComponent;
   using seconds = SmartGridToolbox::posix_time::seconds;
   using SmartGridToolbox::Simulation;

   // Create the model:
   Model mod;

   // Now populate the model using factory functionality of Model.
   // The RegularUpdateComponent does nothing other than regularly update itself, every 1 second in this case.
   RegularUpdateComponent & ticker1 = 
      mod.newComponent&ltRegularUpdateComponent&gt("ticker_1");
   ticker1.setDt(seconds(1));
   // And here's one that updates every 2 seconds...
   RegularUpdateComponent & ticker2 = 
      mod.newComponent&ltRegularUpdateComponent&gt("ticker_2");
   ticker2.setDt(seconds(2));

   mod.validate();

   // Set up the simulation.
   Simulation sim(mod);
   sim.setStartTime(seconds(0));
   sim.setEndTime(seconds(5));
   sim.initialize();

   std::cout << "Initial timestep : simulation is at time = " << sim.currentTime() << "." << std::endl;
   std::cout << "                 : ticker_1 is at time = " << ticker1.time() << "." << std::endl;
   std::cout << "                 : ticker_2 is at time = " << ticker2.time() << "." << std::endl;
   std::cout << std::endl;
   while (sim.doTimestep())
   {
      std::cout << "New timestep     : simulation is at time = " << sim.currentTime() << "." << std::endl;
      std::cout << "                 : ticker_1 is at time = " << ticker1.time() << "." << std::endl;
      std::cout << "                 : ticker_2 is at time = " << ticker2.time() << "." << std::endl;
      std::cout << std::endl;
   }
}</code></pre>
				</p>
				<p>
					It illustrates both how to set up a simple SmartGridToolbox program, and certain simple aspects of the event based simulation architecture.
				</p>
				<p>
					The output, upon running the program above, is:
					<pre><code>MESSAGE:	Component ticker_1 added to model.
MESSAGE:	Component ticker_2 added to model.
MESSAGE:	Model after validation:
MESSAGE:		ticker_1 0
MESSAGE:		ticker_2 0
Initial timestep : simulation is at time = 00:00:00.
                 : ticker_1 is at time = 00:00:00.
                 : ticker_2 is at time = 00:00:00.

New timestep     : simulation is at time = 00:00:01.
                 : ticker_1 is at time = 00:00:01.
                 : ticker_2 is at time = 00:00:00.

New timestep     : simulation is at time = 00:00:02.
                 : ticker_1 is at time = 00:00:02.
                 : ticker_2 is at time = 00:00:02.

New timestep     : simulation is at time = 00:00:03.
                 : ticker_1 is at time = 00:00:03.
                 : ticker_2 is at time = 00:00:02.

New timestep     : simulation is at time = 00:00:04.
                 : ticker_1 is at time = 00:00:04.
                 : ticker_2 is at time = 00:00:04.</code></pre>
				</p>
				<p>
					Note that at each timestep, more than one component update may occur. To get finer control over the updates, so that looping occurs at every single component update, we can change <code>while (sim.doTimestep())</code> to <code>while (sim.doNextUpdate())</code>. <strong>Exercise: copy the tutorial directory and try it</strong>. 
				<p> 
					Also note that when the simulation is at a given time, there may be components that have not yet updated to that time. This will be the case when they have not required a <em>scheduled update</em> at that time, and no other component has requested that they require a <em>contingent update</em> - but more about this later.
				</p>
				<h5><a name="config-files" class="anchor" href="#config-files"></a>Using YAML Configuration Files</h5>
				<p>
					In the example above, we added components to the simulation programmatically. In most SmartGridToolbox programs, the components will instead be parsed in from a YAML configuration file. The following example is from <code>SmartGridToolbox/tutorials/IntroductionToSgt/src/test_overhead_line.cc</code>, and the YAML configuration file that gets parsed in can be found in <code>SmartGridToolbox/tutorials/IntroductionToSgt/src/test_overhead_line.yaml</code>.
				</p>
<pre><code>#include <SmartGridToolbox.h>

int main()
{
   //using namespace SmartGridToolbox;
   using SmartGridToolbox::Bus;
   using SmartGridToolbox::Model;
   using SmartGridToolbox::Parser;
   using SmartGridToolbox::Simulation;
   using SmartGridToolbox::operator<<;

   Model mod;
   Simulation sim(mod);
   Parser & p = Parser::globalParser();
   p.parse("test_overhead_line.yaml", mod, sim); p.postParse();
   mod.validate();
   sim.initialize();
   // That's it!

   // Since there is no time dependence this model, none of the components will
   // ever undergo an update. But, the initial call to sim.initialize() will
   // ensure that the model is put into a valid state, with its time equal to
   // the start time of the simulation in the yaml configuration file. Thus,
   // the power flow equations will already be solved. We can look at the 
   // voltages etc. on the busses:
   
   Bus * bus_1 = mod.component&ltBus&gt("bus_1");
   Bus * bus_2 = mod.component&ltBus&gt("bus_2");

   std::cout << "Bus 1 complex voltage = " << bus_1->V() << std::endl;
   std::cout << "Bus 2 complex voltage = " << bus_2->V() << std::endl;
}</code></pre>
				<p>
					Immediately following the call to <code>p.parse(...)</code>, it is also possible to add additional components programmatically. This must be done <em>before</em> <code>mod.validate()</code> is called. <strong>Exercise: add in the "tickers" from the first example to the model</strong>. It is also possible to <em>replace</em> a component with another, using the <code>Model::replaceComponentWithNew(...)</code> function. Again, this should be done after the call to <code>p.parse(...)</code> but before the call to <code>mod.validate()</code>. The usual use for replacing or adding components is to include custom component types, in cases where you wish to avoid having to write a YAML parser for the component.
				</p>
			</section>
		</div>
	</body>
</html>
