<!DOCTYPE html>
<html>
	<head>
		<meta charset='utf-8' />
		<meta http-equiv="X-UA-Compatible" content="chrome=1" />
		<meta name="description" content="NICTA SmartGridToolbox : Microgrid tutorial" />
		<link rel="stylesheet" type="text/css" media="screen" href="stylesheets/stylesheet.css">
		<title>NICTA SmartGridToolbox Architecture</title>
	</head>
	<body>
	<!-- MAIN CONTENT -->
		<div id="main_content_wrap" class="outer">
			<section id="main_content" class="inner">
				<p>
					<img src="https://github.inside.nicta.com.au/dgordon/SmartGridToolbox/blob/master/images/logo.png?raw=true" alt="SmartGridToolbox Logo">
				</p>
				<h3><a name="sgt-architecture" class="anchor" href="#sgt-architecture"></a>Introduction to the SmartGridToolbox Architecture</h3>
				<p>
					SmartGridToolbox is a library that can be used to rapidly develop simulations of of smart grid and microgrid systems. It is written in C++11, and users will need access to a compiler that can handle this C++ specification.
				</p>
				<h4><a name="sgt-library" class="anchor" href="#sgt-library"></a>SmartGridToolbox libraries</h4>
				<p>
					SmartGridToolbox consists of two libraries: <strong>SgtCore</strong> , which contains core utilities and powerflow modelling tools and solvers, and <strong>SgtSim</strong>, which contains the simulation architecture and simulation components. SgtCore may be used in a standalone manner, for non-simulation based tasks. SgtSim is built on top of SgtCore. In the following, we will assume that SmartGridToolbox has already been compiled and installed in the default location, <code>/usr/local</code>.
				</p>
				<h4><a name="sgt-library" class="anchor" href="#sgt-library"></a>Including and linking the SmartGridToolbox libraries</h4>
				<p>
					SmartGridToolbox programs will need to link to the SmartGridToolbox libraries, and will need to include the relevant SmartGridToolbox header files.
				</p>
				<p>
					Header files may be included individually, as follows, e.g.:
<pre><code>#include &ltSgtCore/Network.h&gt
#include &ltSgtSim/Simulation.h&gt
</code></pre>
					or they may be all included automatically using 
<pre><code>#include &ltSgtCore.h&gt
#include &ltSgtSim.h&gt
</code></pre>
				</p>
				<p>
					SmartGridToolbox uses GNU autotools a build system, and builds libraries using libtool. By default, static libraries only are built; for dynamic libraries, SmartGridToolbox should be <code>configure</code>d with the <code>--enable-shared</code> option.
				</p>
				<p>
					The easiest cross-platform way to link to your application is to also use libtool with the GNU autotools. <code>SmartGridToolbox/examples/ResidentialA/Makefile.am</code> gives an example of how to do this. Libtool handles all library dependencies, and correctly handles shared libraries in a manner that is appropriate for the architecture.
				</p>
				<p>
					Otherwise, you must choose	the correct static and dynamic libraries. To statically link a program, the following link flags will work: <code>-lSgtCore -lSgtSim -larmadillo -lboost_date_time -lyaml-cpp</code>. If your program is using <code>SgtCore</code> only, then obviously the <code>-lSgtSim</code> flag should be omitted.
				</p>
				<h4><a name="sgt-program-structure" class="anchor" href="#sgt-program-structure"></a>Basic structure of a SmartGridToolbox program</h4>
				<p>
					At the top level, a SmartGridToolbox simulation consists of a <code>Simulation</code> object, which manages the elements, or <code>Component</code>s, and controls the way time advances as the simulation progresses.
				</p>
				<p>
					The following simple program can be found in <code>SmartGridToolbox/tutorials/IntroductionToSgt/src/tickers.cc</code>.
<pre><code>#include &ltSmartGridToolbox.h&gt

int main()
{
   using SmartGridToolbox::Model;
   using SmartGridToolbox::RegularUpdateComponent;
   using seconds = SmartGridToolbox::posix_time::seconds;
   using SmartGridToolbox::Simulation;

   // Create the model:
   Model mod;

   // Now populate the model using factory functionality of Model.
   // The RegularUpdateComponent does nothing other than regularly update itself, every 1 second in this case.
   RegularUpdateComponent & ticker1 = 
      mod.newComponent&ltRegularUpdateComponent&gt("ticker_1");
   ticker1.setDt(seconds(1));
   // And here's one that updates every 2 seconds...
   RegularUpdateComponent & ticker2 = 
      mod.newComponent&ltRegularUpdateComponent&gt("ticker_2");
   ticker2.setDt(seconds(2));

   mod.validate();

   // Set up the simulation.
   Simulation sim(mod);
   sim.setStartTime(seconds(0));
   sim.setEndTime(seconds(5));
   sim.initialize();

   std::cout << "Initial timestep : simulation is at time = " << sim.currentTime() << "." << std::endl;
   std::cout << "                 : ticker_1 is at time = " << ticker1.time() << "." << std::endl;
   std::cout << "                 : ticker_2 is at time = " << ticker2.time() << "." << std::endl;
   std::cout << std::endl;
   while (sim.doTimestep())
   {
      std::cout << "New timestep     : simulation is at time = " << sim.currentTime() << "." << std::endl;
      std::cout << "                 : ticker_1 is at time = " << ticker1.time() << "." << std::endl;
      std::cout << "                 : ticker_2 is at time = " << ticker2.time() << "." << std::endl;
      std::cout << std::endl;
   }
}</code></pre>
				</p>
				<p>
					It illustrates both how to set up a simple SmartGridToolbox program, and certain simple aspects of the event based simulation architecture.
				</p>
				<p>
					The output, upon running the program above, is:
					<pre><code>MESSAGE:	Component ticker_1 added to model.
MESSAGE:	Component ticker_2 added to model.
MESSAGE:	Model after validation:
MESSAGE:		ticker_1 0
MESSAGE:		ticker_2 0
Initial timestep : simulation is at time = 00:00:00.
                 : ticker_1 is at time = 00:00:00.
                 : ticker_2 is at time = 00:00:00.

New timestep     : simulation is at time = 00:00:01.
                 : ticker_1 is at time = 00:00:01.
                 : ticker_2 is at time = 00:00:00.

New timestep     : simulation is at time = 00:00:02.
                 : ticker_1 is at time = 00:00:02.
                 : ticker_2 is at time = 00:00:02.

New timestep     : simulation is at time = 00:00:03.
                 : ticker_1 is at time = 00:00:03.
                 : ticker_2 is at time = 00:00:02.

New timestep     : simulation is at time = 00:00:04.
                 : ticker_1 is at time = 00:00:04.
                 : ticker_2 is at time = 00:00:04.</code></pre>
				</p>
				<p>
					Note that at each timestep, more than one component update may occur. To get finer control over the updates, so that looping occurs at every single component update, we can change <code>while (sim.doTimestep())</code> to <code>while (sim.doNextUpdate())</code>. <strong>Exercise: copy the tutorial directory and try it</strong>. 
				<p> 
					Also note that when the simulation is at a given time, there may be components that have not yet updated to that time. This will be the case when they have not required a <em>scheduled update</em> at that time, and no other component has requested that they require a <em>contingent update</em> - but more about this later.
				</p>
				<h5><a name="config-files" class="anchor" href="#config-files"></a>Using YAML Configuration Files</h5>
				<p>
					In the example above, we added components to the simulation programmatically. In most SmartGridToolbox programs, the components will instead be parsed in from a YAML configuration file. The following example is from <code>SmartGridToolbox/tutorials/IntroductionToSgt/src/test_overhead_line.cc</code>, and the YAML configuration file that gets parsed in can be found in <code>SmartGridToolbox/tutorials/IntroductionToSgt/src/test_overhead_line.yaml</code>.
				</p>
<pre><code>#include <SmartGridToolbox.h>

int main()
{
   //using namespace SmartGridToolbox;
   using SmartGridToolbox::Bus;
   using SmartGridToolbox::Model;
   using SmartGridToolbox::Parser;
   using SmartGridToolbox::Simulation;
   using SmartGridToolbox::operator<<;

   Model mod;
   Simulation sim(mod);
   Parser & p = Parser::globalParser();
   p.parse("test_overhead_line.yaml", mod, sim); p.postParse();
   mod.validate();
   sim.initialize();
   // That's it!

   // Since there is no time dependence this model, none of the components will
   // ever undergo an update. But, the initial call to sim.initialize() will
   // ensure that the model is put into a valid state, with its time equal to
   // the start time of the simulation in the yaml configuration file. Thus,
   // the power flow equations will already be solved. We can look at the 
   // voltages etc. on the busses:
   
   Bus * bus_1 = mod.component&ltBus&gt("bus_1");
   Bus * bus_2 = mod.component&ltBus&gt("bus_2");

   std::cout << "Bus 1 complex voltage = " << bus_1->V() << std::endl;
   std::cout << "Bus 2 complex voltage = " << bus_2->V() << std::endl;
}</code></pre>
				<p>
					Immediately following the call to <code>p.parse(...)</code>, it is also possible to add additional components programmatically. This must be done <em>before</em> <code>mod.validate()</code> is called. <strong>Exercise: add in the "tickers" from the first example to the model</strong>. It is also possible to <em>replace</em> a component with another, using the <code>Model::replaceComponentWithNew(...)</code> function. Again, this should be done after the call to <code>p.parse(...)</code> but before the call to <code>mod.validate()</code>. The usual use for replacing or adding components is to include custom component types, in cases where you wish to avoid having to write a YAML parser for the component.
				</p>
			</section>
		</div>
	</body>
</html>
